# Digital-image-processing
华科数字图像处理与技术部分作业

具体步骤可以看pdf文件


1、图像放大缩小		resize.m(代码实现的文件名)
先是计算行列的变化比例；再遍历新的图像，每个点都找到原图对应的点的像素值。对于不在整数坐标的点，使用的是最临近插值方法，会选择最近遍历新的图像。

2、 图像旋转		rotate_gray.m	rotate_rgb.m
先判断旋转角度，对于锐角可以直接旋转，大于90°的角度需要先旋转90°，再判断角度，如果还是大于90°，则需再次旋转90°，直到角度变为锐角。
首先计算旋转后的图像大小。如下图所示，这是图像旋转了30度后的图，用蓝色框示意原图位置。原图旋转α度，相反的，旋转后的图像只要旋转-α度就可以回到原图，但是起点的纵坐标相差了一段距离，图中红线表示，在旋转后的图上寻找对应原图的点时，需要先上移红色线段距离，再旋转-α度。红色线段长度为column*sin(α)。
彩色图像和灰度图像一样地旋转方法，只是需要分别旋转RGB三个分量，最后再组合起来就可以了。彩色图像的程序我只编写了锐角的旋转，钝角的旋转与灰度图像相似，就没有写。
  
4、直方图规定化		histogram_spec.m

	对要规定化的原始图像进行直方图均衡化，得出S_k
	对给定直方图进行直方图均衡化，得出v_k
	遍历对每个S遍历v，找到最接近的v，v所表示的映射关系即为s的映射关系。
	用修改过对应关系后的s生成图像g(x,y) 


17、基于频域滤波的基本步骤		fftFliter.m
	将输入图片进行傅里叶变换，得到其频谱图
	保留低频的频谱分量，高频的删去，置为0
	再将滤波后的频谱进行傅里叶反变换，得到输出图像
对于二维图像频谱图，其低频信号是图像中心，越靠近中心的频谱，对还原的图像影响越大，越边缘的频谱影响越小。



20. 请写出Canny算子检测边缘的详细步骤。

1. 高斯滤波
滤波的主要目的是降噪，高斯滤波主要使图像变得平滑，同时也有可能增大了边缘的宽度。

2. 计算梯度值和梯度方向
边缘是灰度值变化较大的像素点的集合。一道黑边一道白边中间就是边缘，它的灰度值变化是最大的，在图像中，用梯度来表示灰度值的变化程度和方向。它可以通过点乘一个Sobel或其它算子得到不同方向的梯度值
 

3. 非极大值抑制
	沿着梯度方向对幅值进行非极大值抑制，而非边缘方向。在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为0。

4. 用双阈值算法检测和连接边缘
	它设置两个阀值，分别为TH和TL。其中大于TH的都被检测为边缘，而低于TL的都被检测为非边缘。对于中间的像素点，如果与确定为边缘的像素点邻接，则判定为边缘；否则为非边缘。


21、区域标记 		zonemarker.m
我采用的是逐行扫描的方法，每一行扫描时，遇到第一个像素1的点时给一个标记。再继续扫描，如果扫描的点像素还是1，判断这个点的上面点是否为0，不为0表示这一行1像素的点是和上一行连通，这时将标记改为上一行的像素值；为0则表示不连通。直到扫描到像素为0的点，代表这行连续的1像素结束了，如果标记不为0，代表与上一行相连，需要将这行连续的1像素点修改为上一行的像素。
    这样做完一遍后会有同一个区域有两个颜色的情况，如下左图所示，这和老师上课说的“山”的例子一样扫描完第二竖、第三竖的像素与第一竖、横的像素不一样，老师说的集合方法MATLAB我没弄好，我就再换了个方法。我再扫描一遍图像，但方向是从下往上扫描，和第一次一样的方法，判断扫描的行是否和下面一行连通，连通则改为下一行的像素，否则保持不变。

 
22、边界跟踪		boundary_following.m
	对图像按行扫描，找到第一个值为1的点，以这个点为起点，记为P0，再定义8个搜索方向
	按逆时针方向顺序依次判断当前点的8个邻接点是否为1，找到第一个为1的点，这个点为边界的下一点。再从这个点开始寻找下一个边界点
	直到找到的下个点的坐标是P1的坐标，并且它前一个点坐标是P0的坐标为止，表示已经循环了一圈，最后再顺序输出边界坐标。



